{
    "version": 2,
    "name": "yuiv2",
    "disableSend": false,
    "placeBeforeInput": false,
    "injectInput": false,
    "qrList": [
        {
            "id": 1,
            "label": "init",
            "title": "",
            "message": "/echo Initializing |\n/if left={{lastMessageId}} rule=neq right=0 \"/abort\" |\n\n/setvar key=firstLoad true |\n/setvar key=output {} |\n/setvar key=maxMainSize 400 |\n/setvar key=gains {\"health\":0,\"energy\":0,\"strength\":0,\"speed\":0} |\n/setvar key=statsExtr meow |\n\n\n/input #{{getvar::pass}}<script type=\"text/javascript\">\n(() => {setTimeout(() => {\n\n//essentials\n//get the popup components we can play with\nconst popup = document.querySelector(\"#dialogue_popup_holder\");\nconst popupHeader = popup.querySelector(\"#dialogue_popup_text\");\nconst popupInput = popup.querySelector(\"#dialogue_popup_input\");\nconst popupControls = popup.querySelector(\"#dialogue_popup_controls\");\nconst okButton = popupControls.querySelector(\"#dialogue_popup_ok\");\nconst cancelButton = popupControls.querySelector(\"#dialogue_popup_cancel\");\n\n//output setter\nconst setReturnValue = (val) => {\n  popupInput.value = val;\n};\n\n//hide/show popup elems - only select: popupHeader, popupInput, okButton, cancelButton\nconst hidePopupElems = (elems) => {\n  elems.forEach((elem) => {\n    elem.style.visibility = \"hidden\"\n    elem.style.position = \"absolute\"\n  })\n};\nconst showPopupElems = (elems) => {\n  elems.forEach((elem) => {\n    elem.style.visibility = \"visible\"\n    elem.style.position = \"static\"\n  })\n};\n\nconst main = () => {\n  hidePopupElems([popupInput]);\n\n  setReturnValue(\"JS unlocked!\")\n  \n  okButton.addEventListener(\"click\", (e) => {\n    showPopupElems([popupHeader, popupInput, okButton, cancelButton])\n  });\n  cancelButton.addEventListener(\"click\", (e) => {\n    showPopupElems([popupHeader, popupInput, okButton, cancelButton])\n  });\n};\n\nmain();\n\n}, 0)})();\n</script>\n\n<h3>Hello and welcome! If you see a \"JS unlocked!\" message after pressing ok, that means your user script is working.</h3> |\n\n/echo",
            "contextList": [],
            "preventAutoExecute": true,
            "isHidden": true,
            "executeOnStartup": false,
            "executeOnUser": false,
            "executeOnAi": false,
            "executeOnChatChange": false,
            "executeOnGroupMemberDraft": false,
            "automationId": ""
        },
        {
            "id": 3,
            "label": "userprocess",
            "title": "",
            "message": "/setvar key=userinput {{input}} |\n\n/getvar index=gameOver output | /setvar key=gameover |\n/if left=gameover rule=eq right=true \"/abort\" |\n\n/setvar key=jbout - |\n/run yuiv2.addstats |\n\n\n/if left=userinput rule=eq right=move \"/run yuiv2.showgameui\"",
            "contextList": [],
            "preventAutoExecute": true,
            "isHidden": true,
            "executeOnStartup": false,
            "executeOnUser": false,
            "executeOnAi": false,
            "executeOnChatChange": false,
            "executeOnGroupMemberDraft": false,
            "automationId": ""
        },
        {
            "id": 5,
            "label": "aiprocess",
            "title": "",
            "message": "/if left={{lastMessageId}} right=0 rule=eq \"/abort\"",
            "contextList": [],
            "preventAutoExecute": true,
            "isHidden": true,
            "executeOnStartup": false,
            "executeOnUser": false,
            "executeOnAi": true,
            "executeOnChatChange": false,
            "executeOnGroupMemberDraft": false,
            "automationId": ""
        },
        {
            "id": 7,
            "label": "Send",
            "title": "",
            "message": "/run yuiv2.userprocess |\n/send {{getvar::userinput}}{{newline}}{{pipe}} |\n/trigger | /flushvar nadanada | /setinput",
            "contextList": [],
            "preventAutoExecute": true,
            "isHidden": false,
            "executeOnStartup": false,
            "executeOnUser": false,
            "executeOnAi": false,
            "executeOnChatChange": false,
            "executeOnGroupMemberDraft": false,
            "automationId": ""
        },
        {
            "id": 9,
            "label": "showgameui",
            "title": "",
            "message": "/input #{{getvar::pass}}<script type=\"text/javascript\">\n(() => {setTimeout(() => {\n\n//essentials\n//get the popup components we can play with\nconst popup = document.querySelector(\"#dialogue_popup_holder\");\nconst popupHeader = popup.querySelector(\"#dialogue_popup_text\");\nconst popupInput = popup.querySelector(\"#dialogue_popup_input\");\nconst popupControls = popup.querySelector(\"#dialogue_popup_controls\");\nconst okButton = popupControls.querySelector(\"#dialogue_popup_ok\");\nconst cancelButton = popupControls.querySelector(\"#dialogue_popup_cancel\");\n\n//output setter\nconst setReturnValue = (val) => {\n  popupInput.value = val;\n};\n\n//hide/show popup elems - only select: popupHeader, popupInput, okButton, cancelButton\nconst hidePopupElems = (elems) => {\n  elems.forEach((elem) => {\n    elem.style.visibility = \"hidden\"\n    elem.style.position = \"absolute\"\n  })\n};\nconst showPopupElems = (elems) => {\n  elems.forEach((elem) => {\n    elem.style.visibility = \"visible\"\n    elem.style.position = \"static\"\n  })\n};\n\nconst mainCont = document.querySelector(\"#main\")\nconst game = mainCont.querySelector(\"#game\")\nconst player = game.querySelector(\"#player\")\nconst goal = game.querySelector(\"#goal\")\nconst hud = document.querySelector(\"#hud\")\nconst maxMainSize = {{getvar::maxMainSize}}\n\nlet movables = []\nlet velocityX = 0\nlet velocityY = 0\nlet speedFactor = 1\nlet distRemain\nlet timeSinceStarted = 0\nlet playerSpeed\nlet playerEnergy\nlet playerStrength\nlet playerHealth\nlet playerVisibility\nlet origSpeed\nlet origHealth\nlet toEcho = \"\"\nlet toJB = \"\"\nlet gameOver\n\n\nlet vals = {}\nconst memo = (key, value) => {\n  if(value === \"\") {\n    return vals[key]\n  }\n  else {\n    vals[key] = value\n    return value\n  }\n}\n\n\nlet unusedPool = {}\nconst pool = (entity, value) => {\n  if(value === \"\") {\n    return unusedPool[entity].pop()\n  }\n  else {\n    if(Object.keys(unusedPool).includes(entity)) {\n      unusedPool[entity].push(value)\n    }\n    else {\n      unusedPool[entity] = []\n      unusedPool[entity].push(value)\n    }\n    return value\n  }\n}\n\n\nconst saveState = () => {\n  let movablesPos = {}\n  let transform\n  let arr\n  movables.forEach((movable) => {\n    const classList = movable.classList\n    transform = movable.style.transform\n    if(Object.keys(movablesPos).includes(classList[2])) {\n      arr = []\n      arr.push(parseFloat(transform.match(REGEX_X_POS)))\n      arr.push(parseFloat(transform.match(REGEX_Y_POS)))\n      movablesPos[classList[2]].push(arr)\n    }\n    else {\n      movablesPos[classList[2]] = []\n      arr = []\n      arr.push(parseFloat(transform.match(REGEX_X_POS)))\n      arr.push(parseFloat(transform.match(REGEX_Y_POS)))\n      movablesPos[classList[2]].push(arr)\n    }\n  })\n\n  transform = goal.style.transform\n  arr = []\n  arr.push(parseFloat(transform.match(REGEX_X_POS)))\n  arr.push(parseFloat(transform.match(REGEX_Y_POS)))\n  \n  let output = {\n    \"playerSpeed\": playerSpeed,\n    \"playerEnergy\": playerEnergy,\n    \"playerStrength\": playerStrength,\n    \"playerHealth\": playerHealth,\n    \"playerVisibility\": playerVisibility,\n    \"origSpeed\": origSpeed,\n    \"origHealth\": origHealth,\n    \"firstLoad\": \"false\",\n    \"speedFactor\": speedFactor,\n    \"movables\": movablesPos,\n    \"goalPos\": arr,\n    \"toEcho\": toEcho,\n    \"toJB\": toJB,\n    \"gameOver\": gameOver,\n    \"vals\": vals\n  }\n\n  setReturnValue(JSON.stringify(output))\n}\n\n\nconst loadState = () => {\n  const firstLoad = {{getvar::firstLoad}}\n\n  if(firstLoad) {\n    playerSpeed = 100\n    playerEnergy = 250\n    playerStrength = 5\n    playerHealth = 100\n    playerVisibility = 150\n    origSpeed = playerSpeed\n    origHealth = playerHealth\n    speedFactor = 1\n    gameOver = \"false\"\n\n    const MAX_DIST = 15000\n    let randX = -MAX_DIST + (MAX_DIST + MAX_DIST) * Math.random()\n    let randY = -MAX_DIST;\n    goal.style.transform = `translateX(${randX}px) translateY(${randY}px)`\n\n    for(let i = 0; i < 10; i++) {\n      randX = Math.floor(Math.random() * playerVisibility) + HALF_SCREEN\n      randY = Math.floor(Math.random() * playerVisibility) + HALF_SCREEN\n      appendEntity(\"tree\", randX, randY)\n    }\n  }\n  else {\n    const output = {{getvar::output}}\n    \n    const stats = {{getvar::gains}}\n    const speedIncrease = stats[\"speed\"]\n    const healthIncrease = stats[\"health\"]\n    const energyIncrease = stats[\"energy\"]\n    const strengthIncrease = stats[\"strength\"]\n\n    visibilityLerp = 0\n    origSpeed = output[\"origSpeed\"] + speedIncrease\n    playerSpeed = Math.max(30, output[\"playerSpeed\"] + speedIncrease)\n    origHealth = output[\"origHealth\"]\n    playerHealth = output[\"playerHealth\"]\n    updateHealth(healthIncrease)\n    playerEnergy = output[\"playerEnergy\"]\n    updateEnergy(energyIncrease)\n    playerStrength = output[\"playerStrength\"] + strengthIncrease\n    playerStrength = Math.max(playerStrength, 0)\n    playerVisibility = output[\"playerVisibility\"]\n    speedFactor = output[\"speedFactor\"]\n    const movablesPos = output[\"movables\"]\n    const goalPos = output[\"goalPos\"]\n    gameOver = output[\"gameOver\"]\n    vals = output[\"vals\"]\n\n    goal.style.transform = `translateX(${goalPos[0]}px) translateY(${goalPos[1]}px)`\n    Object.keys(movablesPos).forEach((entity) => {\n      movablesPos[entity].forEach((pos) => {\n        appendEntity(entity, pos[0], pos[1])\n      })\n    })\n  }\n}\n\n\nlet ticks = {\n  \"200\": 200,\n  \"randomEvent\": 50,\n  \"stats\": 2,\n  \"trickleStats\": 20,\n  \"tickSinceStarted\": 5,\n}\n\n\n//tick frame by frame\nlet looping = false\nlet lastTime\nconst process = (time) => {\n  if(looping === false) {\n    return\n  }\n  if(lastTime === undefined) {\n    lastTime = time\n    window.requestAnimationFrame(process)\n    return\n  }\n  const delta = time - lastTime\n  lastTime = time\n\n  //add functions here\n  moveEntities(delta)\n  tick200(delta)\n  updateVisibility()\n  translateAI(delta)\n\n  //loop again\n  window.requestAnimationFrame(process)\n}\n\n\n//tick per 200ms\nconst tick200 = (delta) => {\n  if(ticks[\"200\"] > 0) {\n    ticks[\"200\"] -= delta\n    return\n  }\n  \n  //functions here\n  trickleStats()\n  randomizeEventInGame()\n  updateStats()\n  updateTimeSinceStarted()\n\n  ticks[\"200\"] = 200;\n}\n\n\n//dist not squared yet\nconst REGEX_X_POS = /(?<=x\\()-?[\\d\\.e\\-]+(?=px)/i\nconst REGEX_Y_POS = /(?<=y\\()-?[\\d\\.e\\-]+(?=px)/i\nconst HALF_SCREEN = maxMainSize * 0.5\nconst MIN_DIST_MEMO = 250\nconst getDistRaw = (entity) => {\n  const transform = entity.style.transform\n  let pX = Math.abs(Math.round(parseFloat(transform.match(REGEX_X_POS)) - HALF_SCREEN))\n  let pY = Math.abs(Math.round(parseFloat(transform.match(REGEX_Y_POS)) - HALF_SCREEN))\n\n  if(Math.abs(pX) <= MIN_DIST_MEMO) {\n    pX = Object.keys(vals).includes(`${pX}`) ?\n      memo(`${pX}`, \"\") : memo(`${pX}`, Math.pow(pX, 2))\n  }\n  else {\n    pX = Math.pow(pX, 2)\n  }\n  if(Math.abs(pY) <= MIN_DIST_MEMO) {\n    pY = Object.keys(vals).includes(`${pY}`) ?\n      memo(`${pY}`, \"\") : memo(`${pY}`, Math.pow(pY, 2))\n  }\n  else {\n    pY = Math.pow(pY, 2)\n  }\n\n  return pX + pY\n}\n\n\nconst HAVEN_REACHED_DIST = 75\nconst stats = hud.querySelector(\"#stats\")\nconst updateStats = () => {\n  if(ticks[\"stats\"] > 0) {\n    ticks[\"stats\"] -= 1\n    return\n  }\n  \n  //distance to goal\n  distRemain = Math.round(Math.sqrt(getDistRaw(goal)))\n  if(distRemain <= HAVEN_REACHED_DIST) {\n    endGame(true)\n  }\n\n  let weather = \"No blizzard\";\n  switch(playerVisibility) {\n    case 150: weather = \"No blizzard\"; break;\n    case 80: weather = \"Moderate blizzard\"; break;\n    case 40: weather = \"Intense blizzard\"; break;\n  }\n\n  stats.innerHTML = `❤️ ${playerHealth} ⚡ ${playerEnergy} 💪 ${playerStrength} 👣 ${playerSpeed}<br>\nDistance left to Haven: ${distRemain}<br>\nWeather: ${weather}`\n\n  ticks[\"stats\"] = 2\n}\n\n\nconst updateTimeSinceStarted = () => {\n  if(ticks[\"tickSinceStarted\"] > 0) {\n    ticks[\"tickSinceStarted\"] -= 1\n    return\n  }\n\n  timeSinceStarted += 1\n  \n  ticks[\"tickSinceStarted\"] = 5\n}\n\n\nconst updateEnergy = (toAdd) => {\n  playerEnergy += toAdd\n  playerEnergy = Math.max(playerEnergy, 0)\n}\n\n\nconst updateSpeed = (toAdd) => {\n  origSpeed += toAdd\n  origSpeed = Math.min(origSpeed, 100)\n  origSpeed = Math.max(origSpeed, 30)\n  playerSpeed += toAdd\n  playerSpeed = Math.min(playerSpeed, origSpeed)\n}\n\n\nconst updateHealth = (toAdd) => {\n  playerHealth += toAdd\n  playerHealth = Math.max(playerHealth, 0)\n  playerHealth = Math.min(playerHealth, origHealth)\n  if(playerHealth <= 0) {\n    endGame(false)\n  }\n}\n\n\nconst trickleStats = () => {\n  if(ticks[\"trickleStats\"] > 0) {\n    ticks[\"trickleStats\"] -= 1\n    return\n  }\n  \n  updateEnergy(-1)\n  if(playerEnergy <= 0) {\n    updateSpeed(-1)\n  }\n  else if(playerEnergy <= 0 && playerSpeed <= 30) {\n    updateHealth(-1)\n  }\n  else {\n    updateSpeed(1)\n  }\n\n  ticks[\"trickleStats\"] = 20\n}\n\n\nconst endGame = (success) => {\n  gameOver = \"true\"\n  const e = new Event(\"click\")\n  if(success) {\n    toEcho = \"You finally reached Haven. Congratulations!\"\n    toJB = `- Haven is reached.\n- {{user}} has experienced Third Man Syndrome.\n- Yui, who guided him on his journey, turns out to be a figment of his imagination.\n- She begins to fade away, becoming transparent and distant.`\n    saveState()\n    okButton.dispatchEvent(e)\n  }\n  else {\n    toEcho = \"Your health ran out. Game over.\"\n    toJB = `- Distance left to Haven: ${distRemain}\n- {{user}} health reaches zero. He dies.`\n    saveState()\n    okButton.dispatchEvent(e)\n  }\n}\n\n\nconst visibileView = document.getElementById(\"visible-view\")\nconst VISIBILITY_LERP_SPEED = 0.001\nlet visibilityLerp = 1\nlet visibilityLast = 200\nconst updateVisibility = () => {\n  if(visibilityLast === playerVisibility) {\n    return\n  }\n\n  visibilityLerp += VISIBILITY_LERP_SPEED\n  if(visibilityLerp > 1) {\n    visibilityLerp = 1\n  }\n\n  visibilityLast = visibilityLast + (playerVisibility - visibilityLast) * visibilityLerp\n  visibileView.style.r = visibilityLast\n}\n\n\nconst randomizeEventInGame = () => {\n  if(ticks[\"randomEvent\"] > 0) {\n    ticks[\"randomEvent\"] -= 1\n    return\n  }\n\n  //in game events here\n  const events = [\"blizzard-intense\", \"blizzard-moderate\", \"blizzard-none\", \"blizzard-none\", \"blizzard-intense\", \"blizzard-moderate\", \"blizzard-none\", \"blizzard-none\", \"ambush\", \"none\", \"none\", \"none\"]\n  const randomEvent = events[Math.floor(Math.random() * events.length)]\n\n  switch(randomEvent) {\n    case \"blizzard-intense\":\n      playerVisibility = 40\n      speedFactor = 0.5\n      visibilityLerp = 0\n      break;\n    case \"blizzard-moderate\":\n      playerVisibility = 80\n      speedFactor = 0.75\n      visibilityLerp = 0\n      break;\n    case \"blizzard-none\":\n      playerVisibility = 150\n      speedFactor = 1\n      visibilityLerp = 0\n      break;\n    case \"ambush\":\n      for(let i = 0; i < 12; i++) {\n        let randX\n        let randY\n        if(i % 4 === 0) {\n          randX = Math.floor(Math.random() * playerVisibility + HALF_SCREEN)\n          randY = HALF_SCREEN - playerVisibility\n        }\n        else if(i % 3 === 0) {\n          randX = HALF_SCREEN - playerVisibility\n          randY = Math.floor(Math.random() * playerVisibility + HALF_SCREEN)\n        }\n        else if(i % 2 === 0) {\n          randX = HALF_SCREEN + playerVisibility\n          randY = Math.floor(Math.random() * playerVisibility + HALF_SCREEN)\n        }\n        else {\n          randX = Math.floor(Math.random() * playerVisibility + HALF_SCREEN)\n          randY = HALF_SCREEN + playerVisibility\n        }\n\n        appendEntity(\"person-running\", randX, randY)\n      }\n      break;\n  }\n\n  ticks[\"randomEvent\"] = 50\n}\n\n\nconst DESPAWN_RANGE = maxMainSize + 50\nconst CLOSE_RANGE = 400\nconst moveEntities = (delta) => {\n  if(velocityX === 0 && velocityY === 0) {\n    return\n  }\n  translateEntity(goal, delta)\n  movables.forEach((movable) => {\n    const t = translateEntity(movable, delta)\n\n    if(t[1] > DESPAWN_RANGE \\|\\| t[0] < -DESPAWN_RANGE \\|\\| t[0] > DESPAWN_RANGE \\|\\| t[1] < -DESPAWN_RANGE) {\n      removeEntity(movable)\n    }\n    else if(movable.classList.contains(\"tree\") === false && getDistRaw(movable) <= CLOSE_RANGE) {\n      beginEncounter(movable)\n    }\n  })\n  spawnEntity()\n}\n\n\nconst beginEncounter = (entity) => {\n  removeEntity(entity)\n  const entityClass = entity.classList\n  const e = new Event(\"click\")\n  distRemain = Math.round(Math.sqrt(getDistRaw(goal)))\n  switch(entityClass[2]) {\n    case \"person-running\":\n      if(entityClass[3] === \"chase\") {\n        toJB = `- Distance left to Haven: ${distRemain}\n- They walk for ${timeSinceStarted} minutes.\n- {{random:A hungry bandit,A strange bipedal creature,A crazy person,An infamous wanted criminal}} catches up to them and wants them dead. Describe what it looks like.`\n      }\n      else if(entityClass[3] === \"flee\") {\n        toJB = `- Distance left to Haven: ${distRemain}\n- They walk for ${timeSinceStarted} minutes.\n- They manage to catch up with a fleeing {{random:hungry bandit,strange bipedal creature,crazy person,infamous wanted criminal}}. Describe what it looks like.`\n      }\n      saveState()\n      okButton.dispatchEvent(e)\n      break;\n    \n    case \"dog\":\n      if(entityClass[3] === \"chase\") {\n        toJB = `- Distance left to Haven: ${distRemain}\n- They walk for ${timeSinceStarted} minutes.\n- A {{random:wild animal,wild animal,wild animal,wild animal,wild animal,wild animal,strange creature,strange creature,strange creature,mythical creature}} catches up to them. It seems very hostile. Describe what it looks like.`\n      }\n      else if(entityClass[3] === \"flee\") {\n        toJB = `- Distance left to Haven: ${distRemain}\n- They walk for ${timeSinceStarted} minutes.\n- They manage to catch up with a fleeing {{random:wild animal,wild animal,wild animal,wild animal,wild animal,strange creature,strange creature,mythical creature}}. Describe what it looks like.`\n      }\n      saveState()\n      okButton.dispatchEvent(e)\n      break;\n    \n    case \"question\":\n      toEcho = \"Found something\"\n      toJB = `- Distance left to Haven: ${distRemain}\n- They walk for ${timeSinceStarted} minutes.\n- They come across {{random: a strange mark in the snow,a dead animal carcass,a human corpse,something very weird}}. Describe what it looks like.`\n      saveState()\n      okButton.dispatchEvent(e)\n      break;\n    \n    case \"sack-xmark\":\n      if(entityClass.length > 3) {\n        toJB = `- Distance left to Haven: ${distRemain}\n- They walk for ${timeSinceStarted} minutes.\n- They manage to catch up with a fleeing running sack, which upon closer inspection is being carried by a small creature. Describe what it looks like.`\n        saveState()\n        okButton.dispatchEvent(e)\n      }\n      else {\n        updateEnergy(Math.floor(Math.random() * 100))\n      }\n      break;\n    \n    case \"hiking\":\n      toJB = `- Distance left to Haven: ${distRemain}\n- They walk for ${timeSinceStarted} minutes.\n- They meet a stranger trudging through the snow. {{random:He,She}} seems {{random:okay,grumpy,angry,weak,strong,up for a trade,happy,dangerous,lonely,to be hiding something}}.`\n      saveState()\n      okButton.dispatchEvent(e)\n      break;\n    \n    case \"prescription-bottle-medical\":\n      updateHealth(20)\n      break;\n    \n    case \"wand-sparkles\":\n      toEcho = \"Found a weapon\"\n      toJB = `- Distance left to Haven: ${distRemain}\n- They walk for ${timeSinceStarted} minutes.\n- They find a weapon.`\n      saveState()\n      okButton.dispatchEvent(e)\n      break;\n    \n    case \"tent\":\n      toEcho = \"Found an abandoned tent\"\n      toJB = `- Distance left to Haven: ${distRemain}\n- They walk for ${timeSinceStarted} minutes.\n- They find an abandoned tent. Describe what it looks like.`\n      saveState()\n      okButton.dispatchEvent(e)\n      break;\n    \n    case \"tree\":\n      toJB = `- Distance left to Haven: ${distRemain}\n- They walk for ${timeSinceStarted} minutes.\n- A big-ass creature that looks like a tree catches up with them. Describe what it looks like. There's no escape with this thing.`\n      saveState()\n      okButton.dispatchEvent(e)\n      break;\n  }\n}\n\n\nconst ENTITY_REGEX = /(?<=movable icon )[\\S]+?(?=\\s\\|$)/i\nconst removeEntity = (entity) => {\n  movables = movables.filter((movable) => entity !== movable)\n  const parent = entity.parentNode\n  const entityClass = entity.getAttribute(\"class\").match(ENTITY_REGEX)[0]\n  parent.removeChild(pool(entityClass, entity))\n}\n\n\nconst SPEED_CONV = 0.001\nconst translateEntity = (entity, delta) => {\n  const transform = entity.style.transform\n\n  const x = Object.keys(vals).includes(`${velocityX} ${playerSpeed} ${speedFactor}`) ?\n    memo(`${velocityX} ${playerSpeed} ${speedFactor}`, \"\") :\n    memo(`${velocityX} ${playerSpeed} ${speedFactor}`, velocityX * playerSpeed * speedFactor * SPEED_CONV)\n  const y = Object.keys(vals).includes(`${velocityY} ${playerSpeed} ${speedFactor}`) ?\n    memo(`${velocityY} ${playerSpeed} ${speedFactor}`, \"\") :\n    memo(`${velocityY} ${playerSpeed} ${speedFactor}`, velocityY * playerSpeed * speedFactor * SPEED_CONV)\n\n  const pX = parseFloat(transform.match(REGEX_X_POS)) + x * delta\n  const pY = parseFloat(transform.match(REGEX_Y_POS)) + y * delta\n  \n  entity.style.transform = `translateX(${pX}px) translateY(${pY}px)`\n  return [pX, pY]\n}\n\n\nconst AI_SPEED_PENALTY = 40\nconst AI_MAX_ACTIVATE = 22500\nconst translateAI = (delta) => {\n  const chasers = movables.filter((movable) => movable.classList.contains(\"chase\"))\n  applyAIVelocity(chasers, \"chase\", delta)\n\n  const fleers = movables.filter((movable) => movable.classList.contains(\"flee\"))\n  applyAIVelocity(fleers, \"flee\", delta)\n}\n\n\nconst applyAIVelocity = (entities, behavior, delta) => {\n  const speed = origSpeed - AI_SPEED_PENALTY\n  entities.forEach((entity) => {\n    if(getDistRaw(entity) > AI_MAX_ACTIVATE) {\n      return\n    }\n    if(getDistRaw(entity) <= CLOSE_RANGE) {\n      beginEncounter(entity)\n      return\n    }\n\n    const transform = entity.style.transform\n\n    const posX = transform.match(REGEX_X_POS) - HALF_SCREEN\n    const posY = transform.match(REGEX_Y_POS) - HALF_SCREEN\n    let rad = Math.atan2(posY, posX)\n    if(rad < 0) {\n      rad += 2*Math.PI\n    }\n\n    const deg = rad * 180 / Math.PI\n\n    let vX = 0\n    let vY = 0\n\n    if(deg < 22.5) {\n      vX = (behavior === \"chase\") ? -1 : 1\n    }\n    else if(deg >= 22.5 && deg < 67.5) {\n      vX = (behavior === \"chase\") ? -DIAG_MOVE_VELOCITY : DIAG_MOVE_VELOCITY\n      vY = (behavior === \"chase\") ? -DIAG_MOVE_VELOCITY : DIAG_MOVE_VELOCITY\n    }\n    else if(deg >= 67.5 && deg < 112.5) {\n      vY = (behavior === \"chase\") ? -1 : 1\n    }\n    else if(deg >= 112.5 && deg < 157.5) {\n      vX = (behavior === \"chase\") ? DIAG_MOVE_VELOCITY : -DIAG_MOVE_VELOCITY\n      vY = (behavior === \"chase\") ? -DIAG_MOVE_VELOCITY : DIAG_MOVE_VELOCITY\n    }\n    else if(deg >= 157.5 && deg < 202.5) {\n      vX = (behavior === \"chase\") ? 1 : -1\n    }\n    else if(deg >= 202.5 && deg < 247.5) {\n      vX = (behavior === \"chase\") ? DIAG_MOVE_VELOCITY : -DIAG_MOVE_VELOCITY\n      vY = (behavior === \"chase\") ? DIAG_MOVE_VELOCITY : -DIAG_MOVE_VELOCITY\n    }\n    else if(deg >= 247.5 && deg < 292.5) {\n      vY = (behavior === \"chase\") ? 1 : -1\n    }\n    else if(deg >= 292.5 && deg < 337.5) {\n      vX = (behavior === \"chase\") ? -DIAG_MOVE_VELOCITY : DIAG_MOVE_VELOCITY\n      vY = (behavior === \"chase\") ? DIAG_MOVE_VELOCITY : -DIAG_MOVE_VELOCITY\n    }\n    else if(deg >= 337.5) {\n      vX = (behavior === \"chase\") ? -1 : 1\n    }\n\n    const x = Object.keys(vals).includes(`${vX} ${speed} ${speedFactor}`) ?\n      memo(`${vX} ${speed} ${speedFactor}`, \"\") :\n      memo(`${vX} ${speed} ${speedFactor}`, vX * speed * speedFactor * SPEED_CONV)\n    const y = Object.keys(vals).includes(`${vY} ${speed} ${speedFactor}`) ?\n      memo(`${vY} ${speed} ${speedFactor}`, \"\") :\n      memo(`${vY} ${speed} ${speedFactor}`, vY * speed * speedFactor * SPEED_CONV)\n\n    const pX = parseFloat(transform.match(REGEX_X_POS)) + x * delta\n    const pY = parseFloat(transform.match(REGEX_Y_POS)) + y * delta\n\n    entity.style.transform = `translateX(${pX}px) translateY(${pY}px)`\n  })\n}\n\n\nconst ENTITY_COUNT_MAX = 100\nconst ENTITY_SPAWN_CHANCE = 8\nconst ENTITY_TABLE = {\n  \"dog\": 6,\n  \"person-running\": 4,\n  \"question\": 1.8,\n  \"sack-xmark\": 1,\n  \"hiking\": 0.8,\n  \"prescription-bottle-medical\": 0.5,\n  \"wand-sparkles\": 0.3,\n  \"tent\": 0.25\n}\nconst spawnEntity = () => {\n  if(movables.length >= ENTITY_COUNT_MAX) {\n    return\n  }\n  if(Math.floor(Math.random() * 100) > ENTITY_SPAWN_CHANCE) {\n    return\n  }\n\n  let randX\n  let randY\n  if(velocityY > 0) {\n    randX = Math.floor(Math.random() * maxMainSize)\n    randY = 0\n  }\n  else if(velocityX > 0) {\n    randX = 0\n    randY = Math.floor(Math.random() * maxMainSize)\n  }\n  else if(velocityX < 0) {\n    randX = maxMainSize\n    randY = Math.floor(Math.random() * maxMainSize)\n  }\n  else if(velocityY < 0) {\n    randX = Math.floor(Math.random() * maxMainSize)\n    randY = maxMainSize\n  }\n\n  const rand = Math.random() * 100\n  let entityToSpawn = \"tree\"\n  const possibleSpawns = Object.keys(ENTITY_TABLE).filter((entity) => rand <= ENTITY_TABLE[entity])\n  if(possibleSpawns.length > 0) {\n    entityToSpawn = possibleSpawns[possibleSpawns.length - 1]\n  }\n\n  appendEntity(entityToSpawn, randX, randY)\n}\n\n\nconst appendEntity = (entity, pX, pY) => {\n  let elem\n  if(Object.keys(unusedPool).includes(entity) && unusedPool[entity].length > 0) {\n    elem = pool(entity, \"\")\n  }\n  else {\n    //create icon\n    const icon = document.createElement(\"i\")\n    icon.setAttribute(\"class\", `fa-solid fa-${entity}`)\n\n    //create div\n    elem = document.createElement(\"div\")\n    \n    elem.appendChild(icon)\n  }\n\n  addClass(elem, entity)\n  game.appendChild(elem)\n  elem.style.transform = `translateX(${pX}px) translateY(${pY}px)`\n  movables.push(elem)\n}\n\n\nconst addClass = (elem, entity) => {\n  switch(entity) {\n    case \"person-running\":\n    case \"dog\":\n      if(playerStrength >= Math.floor(Math.random() * 50)) {\n        elem.setAttribute(\"class\", `movable icon ${entity} flee`)\n      }\n      else {\n        elem.setAttribute(\"class\", `movable icon ${entity} chase`)\n      }\n      break;\n    case \"tree\":\n      if(Math.random() * 100 <= 0.15) {\n        elem.setAttribute(\"class\", `movable icon ${entity} chase`)\n      }\n      else {\n        elem.setAttribute(\"class\", `movable icon ${entity}`)\n      }\n      break;\n    case \"sack-xmark\":\n      if(Math.random() * 100 <= 50) {\n        elem.setAttribute(\"class\", `movable icon ${entity} flee`)\n      }\n      else {\n        elem.setAttribute(\"class\", `movable icon ${entity}`)\n      }\n      break;\n    default: elem.setAttribute(\"class\", `movable icon ${entity}`)\n  }\n}\n\n\nconst DIAG_MOVE_VELOCITY = 0.71\nconst applyVelocity = (e) => {\n  switch(e.code) {\n    case \"ArrowUp\":\n    case \"KeyW\":\n      velocityY = 1\n      break;\n    case \"ArrowLeft\":\n    case \"KeyA\":\n      velocityX = 1\n      break;\n    case \"ArrowRight\":\n    case \"KeyD\":\n      velocityX = -1\n      break;\n    case \"ArrowDown\":\n    case \"KeyS\":\n      velocityY = -1\n      break;\n  }\n  //normalize if moving diagonally\n  if(Math.abs(velocityX) > 0 && Math.abs(velocityY) > 0) {\n    velocityX = velocityX < 0 ? -DIAG_MOVE_VELOCITY : DIAG_MOVE_VELOCITY\n    velocityY = velocityY < 0 ? -DIAG_MOVE_VELOCITY : DIAG_MOVE_VELOCITY\n  }\n}\n\n\nconst removeVelocity = (e) => {\n  switch(e.code) {\n    case \"ArrowUp\":\n    case \"KeyW\":\n      velocityY = 0\n      break;\n    case \"ArrowLeft\":\n    case \"KeyA\":\n      velocityX = 0\n      break;\n    case \"ArrowRight\":\n    case \"KeyD\":\n      velocityX = 0\n      break;\n    case \"ArrowDown\":\n    case \"KeyS\":\n      velocityY = 0\n      break;\n  }\n  velocityX = velocityX === 0 ? 0 : (velocityX < 0) ? -1 : 1\n  velocityY = velocityY === 0 ? 0 : (velocityY < 0) ? -1 : 1\n}\n\n\nconst main = () => {\n  hidePopupElems([popupInput, cancelButton]);\n\n  looping = true\n  window.requestAnimationFrame(process)\n\n  loadState()\n\n  document.removeEventListener(\"keydown\", applyVelocity)\n  document.removeEventListener(\"keyup\", removeVelocity)\n  document.addEventListener(\"keydown\", applyVelocity)\n  document.addEventListener(\"keyup\", removeVelocity)\n\n  okButton.addEventListener(\"click\", (e) => {\n    looping = false\n    showPopupElems([popupHeader, popupInput, okButton, cancelButton])\n  });\n  cancelButton.addEventListener(\"click\", (e) => {\n    looping = false\n    showPopupElems([popupHeader, popupInput, okButton, cancelButton])\n  });\n  okButton.addEventListener(\"mousedown\", (e) => {\n    saveState()\n  });\n  cancelButton.addEventListener(\"mousedown\", (e) => {\n    saveState()\n  });\n};\n\n\nmain();\n\n\n}, 0)})();\n</script>\n\n<hr><hr>\n\n<div id=\"main\">\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\">\n<style>\n#main {border: 1px solid green;\nwidth: {{getvar::maxMainSize}}px;\nheight: {{getvar::maxMainSize}}px;\nmax-width: {{getvar::maxMainSize}}px;\nmax-height: {{getvar::maxMainSize}}px;\nmargin: 0 auto;\ndisplay: flex;\nflex-direction: column;\njustify-content: center;\nalign-items: center;\nposition: relative;\n}\n#ui {border: 1px solid orange;\npadding: 2px;\n}\n#game{width: {{getvar::maxMainSize}}px;\nheight: {{getvar::maxMainSize}}px;\noverflow: hidden;\nposition: relative;\nbackground-color: #C3E3E8;\n}\n#player{top: 50%;\nleft: 50%;\nposition: absolute;\ntransform: translateX(-8px) translateY(-13px);\n}\n.icon{font-size: 16px;\ncolor: #092D0F;\n}\n.movable{position: absolute;\nleft: -8px;\ntop: -13px;\n}\n#line1{border-left: 1px solid green;\nleft: 50%;\nwidth: 1px;\nheight: 100%;\nposition: absolute;\nvisibility: hidden;\n}\n#line2{border-top: 1px solid green;\ntop: 50%;\nwidth: 100%;\nheight: 1px;\nposition: absolute;\nvisibility: hidden;\n}\nsvg{position: absolute;\nwidth: 100%;\nheight: 100%;\n}\n#fog{x: 0;\ny: 0;\nwidth: 100%;\nheight: 100%;\nfill: #C3E3E8;\nmask:url(#mask);\nfill-opacity: \"\";\n}\n#visible-view{cx: 50%;\ncy: 50%;\nr: 150;\nfill: red;\nfilter: blur(20px);\n}\n#rect2{height: 100%;\n}\n#goal{position: absolute;\n}\n.house{font-size: 25px;\nposition: absolute;\n}\n</style>\n\n<div id=\"game\">\n  <div id=\"line1\"></div>\n  <div id=\"line2\"></div>\n  <div id=\"goal\">\n    <i class=\"fa-solid fa-house-chimney house icon\" style=\"transform: translateX(-45px) translateY(-45px)\"></i>\n    <i class=\"fa-solid fa-house house house icon\" style=\"transform: translateX(-10px) translateY(-45px)\"></i>\n    <i class=\"fa-solid fa-house-chimney house icon\" style=\"transform: translateX(25px) translateY(-42px)\"></i>\n    <i class=\"fa-solid fa-house-flag house icon\" style=\"transform: translateX(-10px) translateY(-10px)\"></i>\n    <i class=\"fa-solid fa-house-chimney house icon\" style=\"transform: translateX(21px) translateY(-10px)\"></i>\n    <i class=\"fa-solid fa-house-chimney house icon\" style=\"transform: translateX(-46px) translateY(-10px)\"></i>\n    <i class=\"fa-solid fa-house house icon\" style=\"transform: translateX(22px) translateY(25px)\"></i>\n    <i class=\"fa-solid fa-house house icon\" style=\"transform: translateX(-43px) translateY(20px)\"></i>\n    <i class=\"fa-solid fa-house-chimney house icon\" style=\"transform: translateX(-10px) translateY(25px)\"></i>\n  </div>\n  <div id=\"player\" class=\"icon\"><i class=\"fas fa-hiking\"></i></div>\n</div>\n\n<svg>\n  <defs>\n    <mask id=\"mask\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\">\n      <rect id=\"rect2\" x=\"0%\" y=\"0%\" width=\"100%\" fill=\"#fff\"/>\n      <circle id=\"visible-view\"/>\n    </mask>\n  </defs>\n  <rect id=\"fog\"/>\n</svg>\n\n</div>\n\n<div id=\"hud\">\n<style>\n#hud {font-size: 10px;\nwidth: 100%;\ndisplay: flex;\njustify-content: center;\ngap: 2px;\nz-index: 10;\nmargin-top: 2px;\n}\n#instruct{border: 1px solid orange;\nwidth: 50%;\n}\n#stats{border: 1px solid green;\nwidth: 50%;\n}\n</style>\n<div id=\"instruct\">\n  Press WSAD or arrow keys to move.\n</div>\n<div id=\"stats\">\n\n</div>\n</div><br><hr>\n\n|\n\n/setvar key=outraw |\n/setvar key=varname outraw | /run creamsan.isvardefined |\n/if left={{pipe}} rule=eq right=false \"/abort\" |\n\n/setvar key=output {{getvar::outraw}} |\n\n/getvar index=firstLoad output | /setvar key=firstLoad |\n/getvar index=toEcho output | /echo |\n/getvar index=toJB output | /setvar key=jbout |\n/setvar key=gains {\"health\":0,\"energy\":0,\"strength\":0,\"speed\":0} |\n\n/pass Continue moving. | /setvar key=userinput |\n/flushvar nadanada",
            "contextList": [],
            "preventAutoExecute": true,
            "isHidden": true,
            "executeOnStartup": false,
            "executeOnUser": false,
            "executeOnAi": false,
            "executeOnChatChange": false,
            "executeOnGroupMemberDraft": false,
            "automationId": ""
        },
        {
            "id": 11,
            "label": "addstats",
            "title": "",
            "message": "/setvar key=tomsgprocess {{lastMessage}} |\n/setvar key=startregex ```\\s* |\n/setvar key=endregex \\s*``` |\n/run creamsan.regextract | /setvar key=extr |\n\n/setvar key=varname extr |\n/run creamsan.isvardefined |\n/if left={{pipe}} rule=eq right=false \"/setvar key=extr meow \\| /abort\" |\n\n/input #{{getvar::pass}}<script type=\"text/javascript\">\n(() => {setTimeout(() => {\n\n//essentials\n//get the popup components we can play with\nconst popup = document.querySelector(\"#dialogue_popup_holder\");\nconst popupHeader = popup.querySelector(\"#dialogue_popup_text\");\nconst popupInput = popup.querySelector(\"#dialogue_popup_input\");\nconst popupControls = popup.querySelector(\"#dialogue_popup_controls\");\nconst okButton = popupControls.querySelector(\"#dialogue_popup_ok\");\nconst cancelButton = popupControls.querySelector(\"#dialogue_popup_cancel\");\n\n//output setter\nconst setReturnValue = (val) => {\n  popupInput.value = val;\n};\n\n//hide/show popup elems - only select: popupHeader, popupInput, okButton, cancelButton\nconst hidePopupElems = (elems) => {\n  elems.forEach((elem) => {\n    elem.style.visibility = \"hidden\"\n    elem.style.position = \"absolute\"\n  })\n};\nconst showPopupElems = (elems) => {\n  elems.forEach((elem) => {\n    elem.style.visibility = \"visible\"\n    elem.style.position = \"static\"\n  })\n};\n\n\nconst addStats = () => {\n  const firstLoad = {{getvar::firstLoad}}\n  let newGains = {}\n\n  if(firstLoad) {\n    newGains = {\n      \"health\": 0,\n      \"energy\": 0,\n      \"strength\": 0,\n      \"speed\": 0\n    }\n  }\n  else {\n    const extr = `{{getvar::extr}}`\n    const gains = {{getvar::gains}}\n    const health = parseInt(extr.match(/(?<=health\\s?[:\\-]\\s)[\\+\\-]?\\d*?(?=\\s)/i)) + gains[\"health\"]\n    const energy = parseInt(extr.match(/(?<=energy\\s?[:\\-]\\s)[\\+\\-]?\\d*?(?=\\s)/i)) + gains[\"energy\"]\n    const strength = parseInt(extr.match(/(?<=strength\\s?[:\\-]\\s)[\\+\\-]?\\d*?(?=\\s)/i)) + gains[\"strength\"]\n    const speed = parseInt(extr.match(/(?<=speed\\s?[:\\-]\\s)[\\+\\-]?\\d*?(?=\\s\\|$)/i)) + gains[\"speed\"]\n\n    newGains = {\n      \"health\": health,\n      \"energy\": energy,\n      \"strength\": strength,\n      \"speed\": speed\n    }\n  }\n\n  setReturnValue(JSON.stringify(newGains))\n}\n\n\nconst main = () => {\n  hidePopupElems([popupInput]);\n\n  addStats()\n\n  okButton.addEventListener(\"click\", (e) => {\n    showPopupElems([popupHeader, popupInput, okButton, cancelButton])\n  });\n  cancelButton.addEventListener(\"click\", (e) => {\n    showPopupElems([popupHeader, popupInput, okButton, cancelButton])\n  });\n\n  let ev = new Event(\"click\")\n  okButton.dispatchEvent(ev)\n};\n\nmain();\n\n}, 0)})();\n</script>\n\n<h3>Please wait. If this popup is stuck, there's probably an error.</h3>\n\n|\n\n/setvar key=outraw |\n/setvar key=varname outraw | /run creamsan.isvardefined |\n/if left={{pipe}} rule=eq right=false \"/abort\" |\n\n/setvar key=gains {{getvar::outraw}} |\n\n/flushvar nadanada",
            "contextList": [],
            "preventAutoExecute": true,
            "isHidden": true,
            "executeOnStartup": false,
            "executeOnUser": false,
            "executeOnAi": false,
            "executeOnChatChange": false,
            "executeOnGroupMemberDraft": false,
            "automationId": ""
        }
    ],
    "idIndex": 12
}